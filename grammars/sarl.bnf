{
  parserClass='io.sarl.idea.language.parser.SarlParser'
  parserUtilClass='io.sarl.idea.language.parser.SarlParserUtil'

  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'

  psiClassPrefix='Sarl'
  psiImplClassSuffix='Impl'
  psiPackage='io.sarl.idea.language.psi'
  psiImplPackage='io.sarl.idea.language.psi.impl'

  elementTypeHolderClass='io.sarl.idea.language.psi.SarlTypes'
  elementTypeClass='io.sarl.idea.language.psi.SarlElementType'
  tokenTypeClass='io.sarl.idea.language.psi.SarlTokenType'

  psiImplUtilClass='io.sarl.idea.language.psi.impl.SarlPsiImplUtil'

  extends(".*expr")=expr
  extends(".*statement")=statement

  implements("class_declaration|interface_declaration|agent_declaration|event_declaration|skill_declaration|capacity_declaration|behavior_declaration|method_declaration|val_declaration|var_declaration")='io.sarl.idea.language.psi.SarlIdentifiable'

  tokens = [
    LB = '{'
    RB = '}'
    LBR = '['
    RBR = ']'
    LP = '('
    RP = ')'
    COMMA = ','
    COLON = ':'
    SEMICOLON = ';'
    DOT = '.'

    OP_EQUAL = '=='
    OP_NOT_EQUAL = '!='
    OP_GT = '>'
    OP_LT = '<'
    OP_GEQ = '>='
    OP_LEQ = '<='
    OP_AND = '&&'
    OP_OR = '||'

    OP_EQ = '='
    OP_MINUS = '-'
    OP_PLUS = '+'
    OP_TIMES = '*'
    OP_DIV = '/'
    OP_MOD = '%'

    package = 'package'
    import = 'import'
    class = 'class'
    interface = 'interface'
    agent = 'agent'
    event = 'event'
    behavior = 'behavior'
    skill = 'skill'
    capacity = 'capacity'
    private = 'private'
    public = 'public'
    protected = 'protected'
    abstract = 'abstract'
    extends = 'extends'
    implements = 'implements'
    on = 'on'
    val = 'val'
    return = 'return'
    occurrence = 'occurrence'
    this = 'this'
    if = 'if'
    else = 'else'
    break = 'break'
    continue = 'continue'
    true = 'true'
    false = 'false'
    while = 'while'
    do = 'do'
    for = 'for'
    new = 'new'
    static = 'static'

    STRING = 'regexp:"[^"]*"'
    NUMBER = 'regexp:[0-9]+'

    IMPORT_PACKAGE = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)*\.\*'
    SIMPLE_IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
//    DOT_IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)*'
//    DOT_IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
    LINE_COMMENT = 'regexp://.*'
    BLOCK_COMMENT = 'regexp:/\*.*?\*/'
    WHITE_SPACE = 'regexp:\s+'
  ]
}

sarl_file ::= package_declaration? import_declarations? type_declaration?

package_declaration ::= package identifier
import_declarations ::= import_declaration+
import_declaration ::= import (IMPORT_PACKAGE | identifier)

private type_declaration ::= class_declaration |
        interface_declaration |
        agent_declaration |
        event_declaration |
        behavior_declaration |
        skill_declaration |
        capacity_declaration

class_declaration ::= visibility_modifier? abstract? class identifier extends_section? implements_section? LB class_body? RB
interface_declaration ::= visibility_modifier? interface identifier extends_section? LB interface_body RB
agent_declaration ::= agent identifier LB agent_body? RB
event_declaration ::= event identifier LB event_body? RB
skill_declaration ::= skill identifier LB skill_body? RB
behavior_declaration ::= abstract? behavior identifier LB behavior_body? RB
capacity_declaration ::= capacity identifier LB capacity_body? RB
visibility_modifier ::= public | private | protected
extends_section ::= extends identifier (COMMA identifier)*
implements_section ::= implements identifier (COMMA identifier)*

identifier ::= SIMPLE_IDENTIFIER DOT identifier | SIMPLE_IDENTIFIER
//type_identifier ::= (DOT_IDENTIFIER | SIMPLE_IDENTIFIER)

class_body ::= (static_constructor_declaration | member_declaration | constructor_declaration | method_declaration)+
event_body ::= (member_declaration | constructor_declaration | method_declaration)+
skill_body ::= (member_declaration | constructor_declaration | method_declaration)+
interface_body ::= (member_declaration | method_declaration)+
capacity_body ::= (member_declaration | method_declaration)+
agent_body ::= (uses_declaration | member_declaration | constructor_declaration | on_declaration | method_declaration)+
behavior_body ::= (uses_declaration | member_declaration | constructor_declaration | on_declaration | method_declaration)+

static_constructor_declaration ::= static new LB statement_list RB
constructor_declaration ::= visibility_modifier? abstract? new LP parameter_declaration_list? RP LB statement_list RB
member_declaration ::= static? visibility_modifier? (val_declaration | var_declaration)
method_declaration ::= static? visibility_modifier? abstract? def identifier LP parameter_declaration_list? RP LB statement_list? RB
on_declaration ::= on identifier lambda_expr? LB statement_list RB
parameter_declaration_list ::= parameter_declaration (COMMA parameter_declaration)*
parameter_declaration ::= SIMPLE_IDENTIFIER variable_type

uses_declaration ::= uses identifier (COMMA identifier)*
val_declaration ::= val identifier variable_type? variable_initializer?
var_declaration ::= var identifier variable_type? variable_initializer?
variable_type ::= COLON identifier
variable_initializer ::= OP_EQ expr

statement_list ::= statement*
statement ::=
    val_declaration_statement |
    var_declaration_statement |
    return_statement |
    function_call_statement |
    if_statement |
    while_statement |
    do_while_statement |
    for_statement |
    break_statement |
    continue_statement
val_declaration_statement ::= val_declaration
var_declaration_statement ::= var_declaration
function_call_statement ::= function_call_expr
return_statement ::= return expr
if_statement ::= if_expr
break_statement ::= break
continue_statement ::= continue
while_statement ::= while LP expr RP (statement | LB statement_list RB)
do_while_statement ::= do LB statement_list RB while LP expr RP
for_statement ::= for LP identifier COLON expr RP (statement | LB statement_list RB)

expr ::=
    assign_expr |
    boolean_group |
    compare_group |
    add_group |
    mul_group |
    unary_group |
    primary_group

private unary_group ::= unary_plus_expr | unary_min_expr
private mul_group ::= mul_expr | div_expr
private add_group ::= plus_expr | minus_expr
private compare_group ::= compare_expr
private boolean_group ::= boolean_expr
private primary_group ::= new_expr | function_call_expr | lambda_expr | field_access_expr | ref_expr | literal_expr | paren_expr

assign_expr ::= expr assign_op expr { rightAssociative=true }
assign_op ::= '=' | '*=' | '/=' | '%=' | '+=' | '-='
compare_expr ::= expr compare_op expr
boolean_expr ::= expr boolean_op expr
boolean_op ::= OP_AND | OP_OR
compare_op ::= OP_EQUAL | OP_NOT_EQUAL | OP_GT | OP_LT | OP_GEQ | OP_LEQ
unary_min_expr ::= OP_MINUS expr
unary_plus_expr ::= OP_PLUS expr
div_expr ::= expr OP_DIV expr
mul_expr ::= expr OP_TIMES expr
minus_expr ::= expr OP_MINUS expr
plus_expr ::= expr OP_PLUS expr
paren_expr ::= '(' expr ')'
field_access_expr ::= expr DOT expr

if_expr ::= if LP expr RP if_content (else else_content)?
if_content ::= statement | LB statement_list RB
else_content ::= statement | LB statement_list RB

lambda_expr ::= LBR (parameter_declaration_list '|')? statement_list RBR

new_expr ::= new identifier LP parameter_list? RP
function_call_expr ::= SIMPLE_IDENTIFIER LP parameter_list? RP lambda_expr?
ref_expr ::= occurrence | this | SIMPLE_IDENTIFIER
literal_expr ::= NUMBER | STRING | false | true

parameter_list ::= parameter (COMMA parameter)*
parameter ::= expr