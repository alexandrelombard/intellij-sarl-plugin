{
    parserClass='io.sarl.idea.language.parser.SarlParser'
    parserUtilClass='io.sarl.idea.language.parser.SarlParserUtil'

    extends='com.intellij.extapi.psi.ASTWrapperPsiElement'

    psiClassPrefix='Sarl'
    psiImplClassSuffix='Impl'
    psiPackage='io.sarl.idea.language.psi'
    psiImplPackage='io.sarl.idea.language.psi.impl'

    elementTypeHolderClass='io.sarl.idea.language.psi.SarlTypes'
    elementTypeClass='io.sarl.idea.language.psi.SarlElementType'
    tokenTypeClass='io.sarl.idea.language.psi.SarlTokenType'

    psiImplUtilClass='io.sarl.idea.language.psi.impl.SarlPsiImplUtil'

    extends(".*expr")=expr

    methods("ref_expr")=[getReference]

    // SarlIdentifiable
    implements("classifier_declaration")='io.sarl.idea.language.psi.SarlIdentifiable'

    // SarlNamedElement
//      mixin("class_declaration|interface_declaration|agent_declaration|event_declaration|skill_declaration|capacity_declaration|behavior_declaration|method_declaration|val_declaration|var_declaration")='io.sarl.idea.language.psi.impl.SarlNamedElementImpl'
//      implements("class_declaration|interface_declaration|agent_declaration|event_declaration|skill_declaration|capacity_declaration|behavior_declaration|method_declaration|val_declaration|var_declaration")='io.sarl.idea.language.psi.SarlNamedElement'
//      methods("class_declaration|interface_declaration|agent_declaration|event_declaration|skill_declaration|capacity_declaration|behavior_declaration|method_declaration|val_declaration|var_declaration")=[getName setName getNameIdentifier]

    tokens=[
        SEMI=';'
        COMMA=','
        COLON=':'
        DOT='.'
        LP='('
        RP=')'
        LB='{'
        RB='}'
        EQ='='

        OP_PLUS_EQ='+='
        OP_MINUS_EQ='-='
        OP_TIMES_EQ='*='
        OP_DIV_EQ='/='
        OP_INC='++'
        OP_DEC='--'
        OP_PLUS='+'
        OP_MINUS='-'
        OP_TIMES='*'
        OP_DIVIDE='/'
        OP_MODULUS='%'
        OP_LEQ='<='
        OP_GEQ='>='
        OP_LT='<'
        OP_GT='>'
        OP_EQ='=='
        OP_NEQ='!='
        OP_OR='||'
        OP_AND='&&'

        break='break'
        continue='continue'
        class='class'
        event='event'
        agent='agent'
        interface='interface'
        skill='skill'
        capacity='capacity'
        val='val'
        var='var'
        package='package'
        import='import'
        public='public'
        private='private'
        protected='protected'
        on='on'
        new='new'
        def='def'
        occurrence='occurrence'

        int='int'
        float='float'
        double='double'
        this='this'
        it='it'
        true='true'
        false='false'

        space='regexp:[ \t]'
        nl='regexp:(\n|\r\n)+'
        ws='regexp:\s+'
        line_comment='regexp://.*'
        block_comment='regexp:/\*(.|\n)*\*/'
        hex_number='regexp:0x([0-9A-Fa-f])+'
        number='regexp:\d+(\.\d*)?'
        string='regexp:"([^"]|\\")*"'
        bool="regexp:true|false"
        id='regexp:[A-Za-z][A-Za-z0-9_]*'
    ]

}

root ::= [ package_declaration ] ws* [ import_statement* ] ws* classifier_declaration

// region Package
package_declaration ::= package ws* package_name
package_name ::= package_unit [(DOT package_unit)*] [DOT '*'] line_break
package_unit ::= id
import_statement ::= import ws* package_name ws*
// endregion

// region Classifiers
classifier_declaration ::= classifier_type ws* valid_identifier (ws|nl)* LB classifier_body RB
classifier_type ::= (class|agent|event|interface|skill|capacity|behavior)
classifier_body ::= (ws|nl)* (constructor_declaration|uses_declaration|member_declaration|method_declaration|on_declaration)* (ws|nl)*

member_visibility ::= public|private|protected
member_declaration ::= [ member_visibility ws* ] variable_declaration ws*
// endregion

// region Variables
variable_declaration ::= variable_mutability ws* valid_identifier (variable_type? variable_initializer | variable_type)
variable_mutability ::= (var|val)
variable_type ::= ws* COLON ws* valid_type ws*
variable_initializer ::= EQ expr
// endregion

// region Functions
method_declaration ::= [ member_visibility ws* ] function_declaration

constructor_declaration ::= new ws* [parameters_declaration] ws* function_body ws*

function_declaration ::= def ws* valid_identifier [parameters_declaration] [ COLON return_type ] (ws|nl)* function_body ws*
return_type ::= valid_type

parameters_declaration ::= LP (ws|nl)* (parameter_declaration (ws|nl)* (COMMA (ws|nl)* parameter_declaration)*)? RP
parameter_declaration ::= valid_identifier ws* COLON ws* valid_type

parameters_list ::= expr [(COMMA expr)*]

function_body ::= LB ws* expression_block ws* RB
// endregion

// region On
on_declaration ::= on valid_identifier [ lambda_expr ] LB ws* expression_block ws* RB ws*
// endregion

// region Uses
uses_declaration ::= ws* uses valid_identifier [(COMMA valid_identifier)*] ws*
// endregion

// region Expression
expression_block ::= (expr (ws* expr)* ws*) | ws*
expr ::= (add_group | mul_group | unary_group | boolean_group | cmp_group | standard_group | structure_group | assign_group | constructor_expr | function_call_expr | (simple_ref_expr | qualified_ref_expr) | primary_group)

private unary_group ::= unary_plus_expr | unary_min_expr | array_access_expr
private boolean_group ::= or_expr | and_expr
private cmp_group ::= lt_expr | gt_expr | geq_expr | leq_expr | eq_expr | neq_expr
private mul_group ::= mul_expr | div_expr
private add_group ::= plus_expr | minus_expr
private standard_group ::= var_expr
private structure_group ::= lambda_expr | if_expr | while_expr | do_while_expr | for_loop_expr | for_each_expr | break_expr | continue_expr
private assign_group ::= assign_expr | plus_eq_expr | minus_eq_expr | times_eq_expr | div_eq_expr | prefix_inc_expr | postfix_inc_expr | prefix_dec_expr | postfix_dec_expr
private primary_group ::= literal_expr | paren_expr | return_expr

lt_expr ::= expr OP_LT expr
gt_expr ::= expr OP_GT expr
geq_expr ::= expr OP_GEQ expr
leq_expr ::= expr OP_LEQ expr
eq_expr ::= expr OP_EQ expr
neq_expr ::= expr OP_NEQ expr
or_expr ::= expr OP_OR expr
and_expr ::= expr OP_AND expr
unary_min_expr ::= OP_MINUS expr
unary_plus_expr ::= OP_PLUS expr
div_expr ::= expr OP_DIVIDE expr
mul_expr ::= expr OP_TIMES expr
plus_expr ::= expr OP_PLUS expr
minus_expr ::= expr OP_MINUS expr
plus_eq_expr ::= expr OP_PLUS_EQ expr
minus_eq_expr ::= expr OP_MINUS_EQ expr
times_eq_expr ::= expr OP_TIMES_EQ expr
div_eq_expr ::= expr OP_DIV_EQ expr
postfix_inc_expr ::= expr OP_INC
prefix_inc_expr ::= OP_INC expr
postfix_dec_expr ::= expr OP_DEC
prefix_dec_expr ::= OP_DEC expr
assign_expr ::= expr EQ expr { rightAssociative=true }
paren_expr ::= LP expr RP
literal_expr ::= hex_number | number | string | true | false
return_expr ::= return expr
array_access_expr ::= expr '[' number ']'
constructor_expr ::= new valid_type LP parameters_list? RP

fake ref_expr ::= expr? DOT valid_identifier
simple_ref_expr ::= valid_identifier {extends=ref_expr elementType=ref_expr}
qualified_ref_expr ::= expr DOT valid_identifier {extends=ref_expr elementType=ref_expr}

var_expr ::= variable_declaration

break_expr ::= break
continue_expr ::= continue

if_expr ::= if LP condition RP if_block [ ws* else else_block ]
if_block ::= (LB ws* expression_block ws* RB | expr)
else_block ::= (LB ws* expression_block ws* RB | expr)
while_expr ::= while condition LB ws* expression_block ws* RB
do_while_expr ::= do LB ws* expression_block ws* RB while LP condition RP
for_each_expr ::= for LP valid_identifier COLON valid_identifier RP LB ws* expression_block ws* RB

for_loop_expr ::= for LP for_loop_init SEMI for_loop_condition SEMI for_loop_step RP LB ws* expression_block ws* RB
for_loop_init ::= expr
for_loop_condition ::= expr
for_loop_step ::= expr

condition ::= expr

function_call_expr ::= valid_identifier LP ws* [parameters_list] ws* RP

lambda_expr ::= '[' ws* [lambda_parameters_list ws* '|' ws*] expression_block ws* ']'
lambda_parameters_list ::= (valid_identifier [COLON valid_type])*

// endregion

// region Identifiers
valid_type ::= valid_identifier | primitive_type
primitive_type ::= int | float | double
valid_identifier ::= this | it | occurrence | id
// endregion

line_break ::= nl+
